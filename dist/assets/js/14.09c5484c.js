(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{369:function(e,t,a){"use strict";a.r(t);var l=a(42),v=Object(l.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"react-时间调度的实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-时间调度的实现"}},[e._v("#")]),e._v(" React 时间调度的实现")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("requestIdleCallback")]),e._v("的问题")])]),e._v(" "),a("blockquote",[a("p",[e._v("兼容性不好。")])]),e._v(" "),a("p",[e._v("之间也讲到过"),a("code",[e._v("requestIdleCallback")]),e._v("是在浏览器每一帧剩余的空闲时间调用回调。")]),e._v(" "),a("ul",[a("li",[e._v("通过"),a("code",[e._v("raf")]),e._v("实现模拟"),a("code",[e._v("requestIdleCallback")])])]),e._v(" "),a("p",[a("img",{attrs:{src:"https://i.loli.net/2021/02/04/krixV7smQg9yNPb.png",alt:"截屏2021-02-04 下午9.15.19.png"}})]),e._v(" "),a("p",[e._v("图中可以看到一帧关键渲染周期之中去做了哪些事件，"),a("code",[e._v("requestIdleCallback")]),e._v("是在一帧绘制完成之后进行的触发。(这一帧画完还存在剩余事件)")]),e._v(" "),a("blockquote",[a("p",[e._v("当然需要注意的是需要额外留出一定的空余时间去安排用户突然的交互。当然React中对于这一点也实现的非常优秀。")])]),e._v(" "),a("p",[e._v("而"),a("code",[e._v("requestAnimationFrame")]),e._v("是在一帧开始绘制前触发(可以打开"),a("code",[e._v("performance")]),e._v("调试进行查看)，其实通过"),a("code",[e._v("raf")]),e._v("可以算出空余时间,通过这一帧的开始时间和这一帧的上限就可以模拟计算出"),a("code",[e._v("requestIdleCallback")]),e._v("的实现。")]),e._v(" "),a("p",[e._v("感兴趣的话可以去 React16 的源码去看，实际上它底层的实现是一个双向链表去安排优先级执行。")])])}),[],!1,null,null,null);t.default=v.exports}}]);
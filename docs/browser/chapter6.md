# 高频事件防抖

## 防抖

高频事件的防抖之前的的防抖`debounce`函数，节流`throttle`函数都是老生常谈了。

这里来讲讲`requestAnimationFrame`这个函数。

来看看关于`rAF`这张图
![截屏2021-02-03 下午9.31.40.png](https://i.loli.net/2021/02/03/y5G8eJ3g1ZEtWD6.png)

这是浏览器一帧的生命周期，可以明显的看到:

1. 当触发一些事件，浏览器开始 js 计算。
2. js 计算完成后浏览器开始一帧的绘制过程。
3. 此时开始`layout`和`paint`之前就会执行`rAF`调用它。
4. 开始布局和绘制以及开始渲染。

这里的`rAF`会在每次绘制之前去调用传入的 func。这样其实就达到了每次动画事件防抖的效果。

```js
let flag = false;
window.addEventListener("pointermove", (e) => {
  if (flag) return;
  flag = true;
  window.requestAnimationFrame(() => {
    changeWidth(); // mock 动画操作
    flag = false;
  });
});
```

浏览器每一帧的渲染之前都会执行`rAF`中的`changeWidth`重新计算元素宽度，这样就达到了`changeWidth`函数的防抖。

之后使用`flag`是因为如果在一帧之中多次调用`rAF`其实也是完全没有意义的，所以使用`flag`标记位，每一帧渲染之前如果还没有执行`rAF`那么就调用一次`rAF`，之后改变标记位，当浏览器在这一帧末尾开始调用`rAF`中的函数的时候将标记为变成`false`以提供下一帧事件中正常继续调用`rAF`。

::: tip
关于`rAF`

1. 为了提高性能和电池寿命，因此在大多数浏览器里，**当 requestAnimationFrame() 运行在后台标签页或者隐藏的`<iframe>` 里时，requestAnimationFrame() 会被暂停调用以提升性能和电池寿命**。(定时器则不会)

2. 回调函数会被传入`DOMHighResTimeStamp`参数，`DOMHighResTimeStamp`指示**当前被 requestAnimationFrame() 排序的回调函数被触发的时间**。在同一个帧中的多个回调函数，它们每一个都会接受到一个相同的时间戳，即使在计算上一个回调函数的工作负载期间已经消耗了一些时间。该时间戳是一个十进制数，单位毫秒，最小精度为 1ms(1000μs)。

:::

来看一个仅仅持续 2s 时间的动画

```js
const divs = document.getElementsByClassName("app");
let start;
// time 其实就是本次raf执行时候距离这个raf第一次开始的时间间隔
const update = (time) => {
  if (!start) {
    start = time;
  }
  let duration = time - start;
  // do some animation
  if (duration < 2000) {
    window.requestAnimationFrame(update);
  }
};
window.addEventListener("load", () => {
  window.requestAnimationFrame(update);
});
```

> 当然`rAF`的返回值是一个 hash 串，通过`cancelAnimationFrame`传入这个返回值可以清除`rAF`.需要注意的是`rAF`需要持续不断的调用才会持续产生效果。

### 对比定时器

如果我们做到每 16 毫秒去渲染一次画面，就能够达到比较流畅的动画效果。对于简单的动画， `setlnterval` 方式勉强能够及格，但是对于稍微复杂一些的动画，脚本方式就顶不住了，比如渲染一帧要花去超过 32 毫秒的时间，那么还用 16 毫秒一个间隔的方式肯定不行。实际上，因为一帧渲染要占用网页线程 32 毫秒，会导致 setlnterval 根本无法以 16 毫秒间隔调用渲染函数，这就产生了明显的动画滞后感，原本一秒钟完成的动画现在要花两秒钟完成，所以这种原始的 setlnterval 方式是肯定不适合复杂的动画的。

> 比如规定一个 2s 内完成的动画，使用定时器的方式往往都不准确。他们的执行是会受到队列中 js 代码执行以及浏览器渲染线程占用的影响导致开始时间不准确以及动画每一次渲染无法保证都是相同的。

使用`rAF`就可以很好的解决这个问题，通过 **`rAF`的参数**进行动态计算。 **每一帧渲染的实际一般都会维持在 16ms，所以说`raf`执行如果快于 16ms 那么也会被放到 16ms 执行一次，如果因为一些问题阻塞导致本次渲染时间增长，那么也可以通过`rAF`函数的参数获取到本次执行动画的间隔时间，从而计算出合理的元素动画变化值。**

setlnterval 和 setTimeout **并不能保证在指定时间间隔或者延迟的情况下准时调用指定函数**。
所以可以换一个思路，当指定函数调用的时候，**根据逝去的时间计算当前这一帧应该显示成什么样子(也就是利用 raf 的参数进行判断)**，这样即使因为浏览器渲染主线程忙碌导致一帧渲染时间超过 16 毫秒，在后续帧谊染时至少内容不会因此滞后，即使达不倒 60fps 的效果，也能保证动画在指定时间内完成。

::: tip
不过有一点需要注意，requestAnimationFrame 是在主线程上完成。这意味着，如果主线程非常繁忙，requestAnimationFrame 的动画效果会大打折扣。
:::

这段代码就可以看出来原理！！！！
因为主线程繁忙`EventLoop`一直没有完成，所以阻塞了浏览器渲染，导致了动画和页面的卡顿。

```js
const div = document.getElementById("app");
let start;
const update = (time) => {
  console.log(time);
  if (!start) {
    start = time;
  }
  // 这段代码深究啊
  let duration = time - start;
  div.style.width = "1000px";
  for (let i of Array.from({ length: 1000000 })) {
    console.log("over");
  }
};
window.addEventListener("mouseover", () => {
  window.requestAnimationFrame(update);
});
```

> `rAF`占据了过多的主线程，造成了主线程阻塞。同时一些用户的交互也会造成卡顿，比如 input 的输入也会等待主线程空闲(当前 raf 执行完成，本次渲染完处理用户交互+raf+渲染)才会执行。

## 内核

既然提到了`rAF`那么就顺道把浏览器的机制进行一并处理下。

### 浏览器的内核是多进程的

1. brower 进程（主进程）

- 负责浏览器的页面展示，与用户交互。如前进，后退
- 页面的前进，后退
- 负责页面的管理，创建和销毁其他进程

2. GPU 进程

- 3D 渲染

3. 插件进程

- 每种类型的插件对应一个进程，仅当使用该插件时才能创建

4. 浏览器渲染进程（浏览器内核）
5. GUI 渲染进程

- DOM 解析， CSS 解析，生成渲染树
- js 引擎线程
- 执行 Js 代码
- 事件触发，管理着一个任务队列
- 异步 HTTP 请求线程
- 定时触发器线程

可以看到 js 引擎是浏览器渲染进程的一个线程。

### 浏览器内核中线程之间的关系

**GUI 渲染线程和 JS 引擎线程互斥**

- js 是可以操作 DOM 的，如果在修改这些元素的同时渲染页面（js 线程和 ui 线程同时运行），那么渲染线程前后获得的元素数据可能就不一致了。
- JS 阻塞页面加载
- js 如果执行时间过长就会阻塞页面

### 进程和线程

进程（process）和线程（thread）是操作系统的基本概念。

- 进程是 CPU 资源分配的最小单位（是能拥有资源和独立运行的最小单位）。
- 线程是 CPU 调度的最小单位（是建立在进程基础上的一次程序运行单位）。

由于每个进程至少要做一件事,所以一个进程至少有一个线程。系统会给每个进程分配独立的内存,因此进程有它独立的资源。同一进程内的各个线程之间共享该进程的内存空间（包括代码段,数据集,堆等）。 进程可以理解为一个工厂不不同车间，相互独立。线程是车间里的工人，可以自己做自己的事情,也可以相互配合做同一件事情。

#### 任务队列

单线程就意味着，所有任务都要排队执行，前一个任务结束，才会执行后一个任务。**如果一个任务需要执行，但此时 JavaScript 引擎正在执行其他任务，那么这个任务就需要放到一个队列中进行等待。等到线程空闲时，就可以从这个队列中取出最早加入的任务进行执行**（类似于我们去银行排队办理业务，单线程相当于说这家银行只有一个服务窗口，一次只能为一个人服务，后面到的就需要排队，而任务队列就是排队区，先到的就优先服务） 注意：如果当前线程空闲，并且队列为空，那每次加入队列的函数将立即执行。

#### setTimeout

setTimeout 的运行机制：执行该语句时，设置一个定时器，定时时间置为多设置的延时，当计数结束后，**将传入的函数加入任务队列，之后的执行就交给任务队列负责**。

来看看这个例子

```js
setTimeout(() => {
  console.log(1);
}, 0);
console.log(2);
```

输出 2， 1；

setTimeout 的第二个参数表示在执行代码前等待的毫秒数。上面代码中，设置为 0，表面意思为 执行代码前等待的毫秒数为 0，即立即执行。但实际上的运行结果我们也看到了，并不是表面上看起来的样子，千万不要被欺骗了。

实际上，上面的代码并不是立即执行的，这是因为 setTimeout 有一个最小执行时间，HTML5 标准规定了 setTimeout()的第二个参数的最小值（最短间隔）不得低于 4 毫秒。 当指定的时间低于该时间时，浏览器会用最小允许的时间作为 setTimeout 的时间间隔，也就是说即使我们把 setTimeout 的延迟时间设置为 0，**实际上可能为 4 毫秒后才事件推入任务队列**。

> 当然它也是一个宏任务，但这在这里并不是我想讲的重点。

```js
setTimeout(() => {
  console.log(111);
}, 100);
```

上面代码表示 100ms 后执行 `console.log(111)`，但实际上实行的时间肯定是大于 100ms 后的， 100ms **只是表示 100ms 后将任务加入到"任务队列"中，必须等到当前代码（执行栈）执行完，主线程才会去执行它指定的回调函数。**要是当前代码耗时很长，有可能要等很久，所以并没有办法保证，回调函数一定会在 setTimeout()指定的时间执行。

#### setTimeout 和 setInterval 区别

- setTimeout: 指定延期后调用函数，每次 setTimeout 计时到后就会去执行，然后执行一段时间后才继续 setTimeout,中间就多了误差，（误差多少与代码的执行时间有关）。
- setInterval：以指定周期调用函数，而 setInterval 则是每次都精确的隔一段时间推入一个事件（但是，事件的执行时间不一定就不准确，还有可能是这个事件还没执行完毕，下一个事件就来了）.

一起来看看这个例子

```js
btn.onclick = function() {
  setTimeout(function() {
    console.log(1);
  }, 250);
};
```

点击该按钮后，首先将 onclick 事件处理程序加入队列。该程序执行后才设置定时器，再有 250ms 后，指定的代码才被**添加到队列中等待执行**。 如果上面代码中的 onclick 事件处理程序执行了 300ms，那么定时器的代码至少要在定时器设置之后的 300ms 后才会被执行。**队列中所有的代码都要等到 javascript 进程空闲之后才能执行，而不管它们是如何添加到队列中的。**
> 注意是先推入了定时器，之后在执行事件处理。

![url](https://pic1.zhimg.com/v2-13c3d7071b5de5f3f04cb94910aa2c6c_r.jpg)

#### setInterval存在的一些问题：

JavaScript中使用 setInterval 开启轮询。**定时器代码可能在代码再次被添加到队列之前还没有完成执行，结果导致定时器代码连续运行好几次，而之间没有任何停顿。而javascript引擎对这个问题的解决是：当使用setInterval()时，仅当没有该定时器的任何其他代码实例时，才将定时器代码添加到队列中。这确保了定时器代码加入到队列中的最小时间间隔为指定间隔。**

但是，这样会导致两个问题：

1、某些间隔被跳过；
2、多个定时器的代码执行之间的间隔可能比预期的小

假设，某个onclick事件处理程序使用setInterval()设置了200ms间隔的定时器。如果事件处理程序花了300ms多一点时间完成，同时定时器代码也花了差不多的时间，就会同时出现跳过某间隔的情况

![](https://pic2.zhimg.com/80/v2-4e5983c1ad8f65a7b439e29cd88e0235_1440w.jpg)

例子中的第一个定时器是在205ms处添加到队列中的，但是直到过了300ms处才能执行。当执行这个定时器代码时，在405ms处又给队列添加了另一个副本。在下一个间隔，即605ms处，第一个定时器代码仍在运行，同时在队列中已经有了一个定时器代码的实例。结果是，*在这个时间点上的定时器代码不会被添加到队列中*

#### requestAnimationFrame

目前大多数设备的屏幕刷新率为60次/秒，如果在页面中有一个动画或者渐变效果，或者用户正在滚动页面，那么浏览器渲染动画或页面的每一帧的速率也需要跟设备屏幕的刷新率保持一致。

+ 卡顿：其中每个帧的预算时间仅比16毫秒多一点（1秒/ 60 = 16.6毫秒）。但实际上，浏览器有整理工作要做，因此您的所有工作是需要在10毫秒内完成。如果无法符合此预算，帧率将下降，并且内容会在屏幕上抖动。此现象通常称为卡顿，会对用户体验产生负面影响。

+ 跳帧: 假如动画切换在 16ms, 32ms, 48ms时分别切换，跳帧就是假如到了32ms，其他任务还未执行完成，没有去执行动画切帧，等到开始进行动画的切帧，已经到了该执行48ms的切帧。就好比你玩游戏的时候卡了，过了一会，你再看画面，它不会停留你卡的地方，或者这时你的角色已经挂掉了。必须在下一帧开始之前就已经绘制完毕;

requestAnimationFrame是浏览器用于定时循环操作的一个接口，类似于setTimeout，主要用途是按帧对网页进行重绘。

在 requestAnimationFrame 之前，主要借助 setTimeout/ setInterval 来编写 JS 动画，而动画的关键在于动画帧之间的时间间隔设置，这个时间间隔的设置有讲究，一方面要足够小，这样动画帧之间才有连贯性，动画效果才显得平滑流畅；另一方面要足够大，确保浏览器有足够的时间及时完成渲染。

显示器有固定的刷新频率（60Hz或75Hz），也就是说，每秒最多只能重绘60次或75次，requestAnimationFrame的基本思想就是与这个刷新频率保持同步，利用这个刷新频率进行页面重绘。此外，使用这个API，一旦页面不处于浏览器的当前标签，就会自动停止刷新。这就节省了CPU、GPU和电力。

**requestAnimationFrame是在主线程上完成。这意味着，如果主线程非常繁忙，requestAnimationFrame的动画效果会大打折扣。**

requestAnimationFrame使用一个回调函数作为参数。这个回调函数会在浏览器重绘之前调用。

#### requestIdleCallback()

> 实验中的特性。
> MDN上的解释：requestIdleCallback()方法将在浏览器的空闲时段内调用的函数排队。这使开发者能够在主事件循环上执行后台和低优先级工作，而不会影响延迟关键事件，如动画和输入响应。函数一般会按先进先调用的顺序执行，然而，如果回调函数指定了执行超时时间timeout，则有可能为了在超时前执行函数而打乱执行顺序。

**requestAnimationFrame会在每次屏幕刷新的时候被调用，而requestIdleCallback则会在每次屏幕刷新时，判断当前帧是否还有多余的时间，如果有，则会调用requestAnimationFrame的回调函数。**

![requestIdleCallback](https://pic1.zhimg.com/v2-4c703880218acf2210f1c3c4e321189c_r.jpg)

图片中是两个连续的执行帧，大致可以理解为两个帧的持续时间大概为16.67，图中黄色部分就是空闲时间。所以，requestIdleCallback中的回调函数仅会在每次屏幕刷新并且有空闲时间时才会被调用.

利用这个特性，我们可以在动画执行的期间，利用每帧的空闲时间来进行数据发送的操作，或者一些优先级比较低的操作，此时不会使影响到动画的性能，或者和requestAnimationFrame搭配，可以实现一些页面性能方面的的优化


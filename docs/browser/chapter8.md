# Web 加载&渲染基本原理

## 从输入 URL 到页面加载显示都完成了什么

- **UI 线程处理请求**

**首先，UI thread。UI 线程**

![截屏2021-03-22 下午9.30.19.png](https://i.loli.net/2021/03/22/V3FTUW5u1ZAd7PC.png)

实际上首先是通过浏览器的 UI 线程接受输入的内容进行处理。

现代浏览器地址栏有两种作用，一个是输入关键字进行搜索引擎搜索。另一个就是输入 URL 进行打开新页面。

所以第一步首先是 UI 线程进行判断，判断是站点还是默认搜索引擎关键字搜索。

接下来如果是一个 URL，才会进行 URL 的解析。

- **UI 线程交给网络线程处理请求**

**接下来 UI 线程会通知网络线程`Network thread`**

![截屏2021-03-22 下午9.35.11.png](https://i.loli.net/2021/03/22/mdpeKuAxFRztVk7.png)

通过网络线程去发起请求，

网络线程第一步肯定是解析输入的域名，将域名解析为`IP`去访问服务器的 IP 地址。（通过 DNS 解析域名为 ip）

> 这里需要注意的是
>
> 当建立`https`链接的时候，`TCP`链接会相较于`HTTP`链接额外再次发起一次链接(多一次挥手)，协商`TLS`协商。

> 当访问到得到 301 的时候，浏览器会重新再次发送请求去访问真正的地址。

- **网络线程将响应数据交给 `Renderer process`渲染进程**

实际上前两步都是在`Browser Process`浏览器进程中去处理，这一步才到达`Renderer Process`渲染进程。

当浏览器进程将资源下载完毕准备好之后，会告诉渲染进程同时将数据传递给渲染进程。

之后页面`tab`的导航会及时更新以及处理历史记录然后开始渲染加载页面。

![截屏2021-03-23 下午2.47.05.png](https://i.loli.net/2021/03/23/FrZoTWNni7qt1kU.png)

**浏览器渲染，`process thread`主进程开始渲染页面**

- 首先主进程拿到文本开始解析文本，解析节点成 DOM。也就是将文本节点解析成`AST`抽象语法树。

* 同时对于 css，调用`css parse`解析`css om`。

::: tip
需要注意的是碰到`js`是会阻塞`dom`和`cssom`的解析的。

但是如果标签存在`defer`/`async`属性就不会。
:::

- `cssom`和`dom`解析完毕后会合成为`renderer Tree`。

> `renderer Tree`会排除`dom Tree`上的一些`display:none`的节点去。`renderer Tree`上就会包含节点信息内容以及对应的样式(大小，布局)。

**当`renderer Tree`构建完成之后主线程就会交给另外两个线程去执行。**

- `raster thread`创建绘画记录，也就是规定哪些元素先画出来哪些后画。

- `compositior Thread`将页面拆分成不同的图层，构建图层树。之后等待每一个图层绘画完毕后，合并(拼接)图层，页面就开始展示了。符合线程，像素画图层。

## JS/CSS 阻塞

关于`renderer process`处理页面渲染时，会同时开启`css parse`和`dom parse`解析`cssom`和`dom`。

但是需要注意的是

1. **首先 HTML 解析在执行的时候，是当 HTML 解析器被脚本阻塞时，解析器虽然会停止构建`DOM`但是仍然会识别该脚本后的资源，并行加进行预加载（提前下载请求资源）。**

2. `CSS parse`和`Dom parse`是并行进行解析的，`Css`的解析并不会阻塞`dom`的解析，但是会阻塞页面的渲染。因为页面渲染是需要依赖`cssom dom`合成的`renderer Tree`，所以`css`会阻塞页面渲染。

3. `css`代码会阻塞`js`的执行，当`cssom`构建的时，`js`执行将会暂停。
